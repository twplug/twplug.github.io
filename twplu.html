<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Firebase API (без UI)</title>
</head>
<body>
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, updateDoc, deleteDoc, collection, query, where, addDoc, getDocs } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Глобальные переменные для Firebase
        let firebaseApp;
        let firestoreDb;
        let firebaseAuth;
        let currentUserId = null;
        let isAuthReady = false;

        // Функции для логирования статуса и ошибок в консоль
        function logError(message) {
            console.error(`Ошибка Firebase API: ${message}`);
        }

        function logStatus(message) {
            console.log(`Статус Firebase API: ${message}`);
        }

        /**
         * Инициализирует Firebase и настраивает слушатель состояния аутентификации.
         * Эта функция должна быть вызвана первой.
         */
        export async function initializeFirebaseAPI() {
            try {
                // Используем глобальные переменные, предоставленные средой Canvas
                const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
                const firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}');

                if (!firebaseConfig || !firebaseConfig.projectId) {
                    logError("Firebase config не найден или неполный.");
                    return;
                }

                firebaseApp = initializeApp(firebaseConfig);
                firestoreDb = getFirestore(firebaseApp);
                firebaseAuth = getAuth(firebaseApp);

                onAuthStateChanged(firebaseAuth, async (user) => {
                    if (user) {
                        currentUserId = user.uid;
                        isAuthReady = true;
                        logStatus("Firebase инициализирован. Ваш ID: " + currentUserId);
                    } else {
                        try {
                            // Если токен не предоставлен, анонимная аутентификация
                            const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
                            if (initialAuthToken) {
                                await signInWithCustomToken(firebaseAuth, initialAuthToken);
                            } else {
                                await signInAnonymously(firebaseAuth);
                            }
                        } catch (error) {
                            logError("Ошибка анонимной аутентификации: " + error.message);
                        }
                    }
                });
            } catch (error) {
                logError("Ошибка инициализации Firebase: " + error.message);
            }
        }

        /**
         * Возвращает ссылку на коллекцию в Firestore.
         * @param {string} collectionName - Имя коллекции.
         * @returns {import('firebase/firestore').CollectionReference} Ссылка на коллекцию.
         */
        function getPublicCollectionRef(collectionName) {
            if (!firestoreDb || !firebaseApp || !firebaseApp.options.projectId) {
                throw new Error("Firebase не инициализирован или projectId отсутствует.");
            }
            return collection(firestoreDb, `artifacts/${firebaseApp.options.projectId}/public/data/${collectionName}`);
        }

        /**
         * Удаляет существующее соединение между двумя пользователями.
         * @param {string} user1 - ID первого пользователя.
         * @param {string} user2 - ID второго пользователя.
         */
        export async function deleteConnection(user1, user2) {
            if (!isAuthReady || !currentUserId) {
                logError("Пользователь не аутентифицирован.");
                return;
            }
            const connectionsCol = getPublicCollectionRef('connections');
            const sortedIds = [user1, user2].sort();
            const connectionId = `${sortedIds[0]}+${sortedIds[1]}`;
            try {
                await deleteDoc(doc(connectionsCol, connectionId));
                logStatus(`Соединение ${connectionId} разорвано.`);
            } catch (error) {
                logError("Ошибка при разрыве соединения: " + error.message);
            }
        }

        /**
         * Отправляет или принимает приглашение на соединение.
         * @param {string} senderId - ID отправителя.
         * @param {string} receiverId - ID получателя.
         */
        export async function sendOrAcceptInvite(senderId, receiverId) {
            if (!isAuthReady || !currentUserId) {
                logError("Пользователь не аутентифицирован.");
                return;
            }
            const invitesCol = getPublicCollectionRef('invites');

            try {
                // Проверяем, есть ли уже исходящее приглашение от отправителя к получателю
                const existingInviteQuery = query(invitesCol,
                    where("senderId", "==", senderId),
                    where("receiverId", "==", receiverId)
                );
                const existingInvites = await getDocs(existingInviteQuery);

                if (!existingInvites.empty) {
                    logStatus(`Приглашение от ${senderId} к ${receiverId} уже существует.`);
                    return;
                }

                // Проверяем, есть ли входящее приглашение от получателя к отправителю (для принятия)
                const reverseInviteQuery = query(invitesCol,
                    where("senderId", "==", receiverId),
                    where("receiverId", "==", senderId),
                    where("status", "==", "pending")
                );
                const reverseInvites = await getDocs(reverseInviteQuery);

                if (!reverseInvites.empty) {
                    // Если есть обратное приглашение, принимаем его и создаем соединение
                    const inviteDoc = reverseInvites.docs[0];
                    await updateDoc(doc(invitesCol, inviteDoc.id), { status: "accepted" });

                    const connectionsCol = getPublicCollectionRef('connections');
                    const sortedIds = [senderId, receiverId].sort();
                    const connectionId = `${sortedIds[0]}+${sortedIds[1]}`;
                    await setDoc(doc(connectionsCol, connectionId), {
                        user1Id: sortedIds[0],
                        user2Id: sortedIds[1],
                        establishedAt: new Date().toISOString()
                    });

                    await deleteDoc(doc(invitesCol, inviteDoc.id)); // Удаляем приглашение после создания соединения
                    logStatus(`Приглашение от ${receiverId} принято. Соединение между ${senderId} и ${receiverId} установлено.`);
                    return;
                }

                // Если нет существующих или обратных приглашений, отправляем новое
                await addDoc(invitesCol, {
                    senderId: senderId,
                    receiverId: receiverId,
                    timestamp: new Date().toISOString(),
                    status: "pending"
                });
                logStatus(`Приглашение отправлено от ${senderId} к ${receiverId}.`);

            } catch (error) {
                logError("Ошибка при отправке/принятии приглашения: " + error.message);
            }
        }

        /**
         * Просматривает и возвращает входящие, исходящие приглашения и активные соединения.
         * @param {string} userId - ID пользователя для просмотра.
         * @returns {Promise<object>} Объект с приглашениями и соединениями.
         */
        export async function viewUserStatus(userId) {
            if (!isAuthReady || !currentUserId) {
                logError("Пользователь не аутентифицирован.");
                return { error: "Пользователь не аутентифицирован." };
            }
            const invitesCol = getPublicCollectionRef('invites');
            const connectionsCol = getPublicCollectionRef('connections');

            let statusData = {
                incomingInvites: [],
                outgoingInvites: [],
                activeConnections: []
            };

            try {
                // Входящие приглашения
                const incomingInvitesQuery = query(invitesCol,
                    where("receiverId", "==", userId),
                    where("status", "==", "pending")
                );
                const incomingInvites = await getDocs(incomingInvitesQuery);
                incomingInvites.forEach(doc => {
                    statusData.incomingInvites.push(doc.data());
                });

                // Исходящие приглашения
                const outgoingInvitesQuery = query(invitesCol,
                    where("senderId", "==", userId),
                    where("status", "==", "pending")
                );
                const outgoingInvites = await getDocs(outgoingInvitesQuery);
                outgoingInvites.forEach(doc => {
                    statusData.outgoingInvites.push(doc.data());
                });

                // Активные соединения
                const connectionsAsUser1Query = query(connectionsCol, where("user1Id", "==", userId));
                const connectionsAsUser2Query = query(connectionsCol, where("user2Id", "==", userId));

                const [connectionsAsUser1, connectionsAsUser2] = await Promise.all([
                    getDocs(connectionsAsUser1Query),
                    getDocs(connectionsAsUser2Query)
                ]);

                const activeConnectionsSet = new Set();
                connectionsAsUser1.forEach(doc => {
                    const data = doc.data();
                    activeConnectionsSet.add(`${data.user1Id}+${data.user2Id}`);
                });
                connectionsAsUser2.forEach(doc => {
                    const data = doc.data();
                    activeConnectionsSet.add(`${data.user1Id}+${data.user2Id}`);
                });
                statusData.activeConnections = Array.from(activeConnectionsSet);

                logStatus(`Статус для пользователя ${userId}:\n${JSON.stringify(statusData, null, 2)}`);
                return statusData;

            } catch (error) {
                logError("Ошибка при просмотре статуса: " + error.message);
                return { error: error.message };
            }
        }

        /**
         * Очищает все ожидающие приглашения, отправленные или полученные пользователем.
         * @param {string} userId - ID пользователя для очистки приглашений.
         */
        export async function clearPendingInvites(userId) {
            if (!isAuthReady || !currentUserId) {
                logError("Пользователь не аутентифицирован.");
                return;
            }
            const invitesCol = getPublicCollectionRef('invites');

            try {
                // Удаляем исходящие приглашения
                const outgoingQuery = query(invitesCol,
                    where("senderId", "==", userId),
                    where("status", "==", "pending")
                );
                const outgoingDocs = await getDocs(outgoingQuery);
                outgoingDocs.forEach(async (docSnapshot) => {
                    await deleteDoc(doc(invitesCol, docSnapshot.id));
                });

                // Удаляем входящие приглашения
                const incomingQuery = query(invitesCol,
                    where("receiverId", "==", userId),
                    where("status", "==", "pending")
                );
                const incomingDocs = await getDocs(incomingQuery);
                incomingDocs.forEach(async (docSnapshot) => {
                    await deleteDoc(doc(invitesCol, docSnapshot.id));
                });

                logStatus(`Все ожидающие приглашения для ${userId} очищены.`);

            } catch (error) {
                logError("Ошибка при очистке приглашений: " + error.message);
            }
        }

        /**
         * Возвращает текущий ID пользователя.
         * @returns {string|null} Текущий ID пользователя или null, если не аутентифицирован.
         */
        export function getCurrentUserId() {
            return currentUserId;
        }

        /**
         * Проверяет, готов ли Firebase к работе (пользователь аутентифицирован).
         * @returns {boolean} True, если Firebase готов, иначе false.
         */
        export function isFirebaseReady() {
            return isAuthReady;
        }

        // Автоматическая инициализация Firebase при загрузке скрипта
        // Это позволяет функциям быть доступными сразу после загрузки.
        initializeFirebaseAPI();
    </script>
</body>
</html>
