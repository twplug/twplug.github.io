<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Зашифрованный Мессенджер</title>
</head>
<body>
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, updateDoc, deleteDoc, collection, query, where, addDoc, getDocs } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        let a, b, c, d = null;
        let e = false;

        const firebaseConfig = {
            apiKey: "AIzaSyCbbbkstsx0b7GMuF2THRZvF7g_IF9bmdY",
            authDomain: "twplub.firebaseapp.com",
            databaseURL: "https://twplub-default-rtdb.firebaseio.com",
            projectId: "twplub",
            storageBucket: "twplub.firebasestorage.app",
            messagingSenderId: "774675126793",
            appId: "1:774675126793:web:d4dbc1c76cca733af8b6d8"
        };

        async function m() {
            try {
                const q = firebaseConfig;

                if (!q || !q.projectId) {
                    console.error("[ERROR] Конфигурация Firebase неполна (отсутствует projectId). Функционал базы данных будет недоступен.");
                    return;
                }

                a = initializeApp(q);
                b = getFirestore(a);
                c = getAuth(a);
                console.log("[INFO] Firebase успешно инициализирован.");

                onAuthStateChanged(c, async (r) => {
                    if (r) {
                        d = r.uid;
                        e = true;
                        console.log(`[INFO] Пользователь аутентифицирован. UID: ${d}`);
                        o();
                    } else {
                        try {
                            console.log("[INFO] Пользователь не аутентифицирован. Попытка анонимного входа...");
                            await signInAnonymously(c);
                        } catch (error) {
                            console.error("[ERROR] Ошибка анонимной аутентификации Firebase:", error);
                        }
                    }
                });
            } catch (error) {
                console.error("[ERROR] Критическая ошибка инициализации Firebase:", error);
            }
        }

        function n(p) {
            return collection(b, `artifacts/${a.options.projectId}/public/data/${p}`);
        }

        async function p(user1, user2) {
            const q = n('connections');
            const sortedIds = [user1, user2].sort();
            const connectionId = `${sortedIds[0]}+${sortedIds[1]}`;
            try {
                await deleteDoc(doc(q, connectionId));
                console.log(`[SUCCESS] Соединение ${connectionId} разорвано.`);
            } catch (error) {
                console.error(`[ERROR] Ошибка при разрыве соединения ${connectionId}:`, error);
            }
        }

        async function q(sender, receiver) {
            const r = n('invites');

            try {
                const s = query(r,
                    where("senderId", "==", sender),
                    where("receiverId", "==", receiver)
                );
                const t = await getDocs(s);

                if (!t.empty) {
                    console.log(`[INFO] Вы уже отправили приглашение ${receiver}.`);
                    return;
                }

                const u = query(r,
                    where("senderId", "==", receiver),
                    where("receiverId", "==", sender)
                );
                const v = await getDocs(u);

                if (!v.empty) {
                    const w = v.docs[0];
                    await updateDoc(doc(r, w.id), { status: "accepted" });

                    const x = n('connections');
                    const y = [sender, receiver].sort();
                    const z = `${y[0]}+${y[1]}`;
                    await setDoc(doc(x, z), {
                        user1Id: y[0],
                        user2Id: y[1],
                        establishedAt: new Date().toISOString()
                    });

                    console.log(`[SUCCESS] Приглашение от ${receiver} принято! Соединение установлено: ${z}`);
                    await deleteDoc(doc(r, w.id));
                    return;
                }

                await addDoc(r, {
                    senderId: sender,
                    receiverId: receiver,
                    timestamp: new Date().toISOString(),
                    status: "pending"
                });
                console.log(`[SUCCESS] Приглашение отправлено ${receiver}. Ожидайте ответа.`);

            } catch (error) {
                console.error("[ERROR] Ошибка при обработке приглашения:", error);
            }
        }

        async function r_view(userId) {
            const s = n('invites');
            const t = n('connections');

            let u = '';

            const v = query(s,
                where("receiverId", "==", userId),
                where("status", "==", "pending")
            );
            const w = await getDocs(v);
            if (w.empty) {
                u += 'Нет входящих приглашений.\n';
            } else {
                u += 'Входящие приглашения (ожидают ответа):\n';
                w.forEach(x => {
                    const y = x.data();
                    u += `   От: ${y.senderId} (Принять: /?${userId}invite${y.senderId})\n`;
                });
            }

            const x = query(s,
                where("senderId", "==", userId),
                where("status", "==", "pending")
            );
            const y = await getDocs(x);
            if (y.empty) {
                u += 'Нет исходящих приглашений.\n';
            } else {
                u += 'Исходящие приглашения (ожидают ответа):\n';
                y.forEach(z => {
                    const A = z.data();
                    u += `   Кому: ${A.receiverId} (Отменить: /?invkill=${userId} - удалит все)\n`;
                });
            }

            const z = query(t, where("user1Id", "==", userId));
            const A = query(t, where("user2Id", "==", userId));

            const [B, C] = await Promise.all([
                getDocs(z),
                getDocs(A)
            ]);

            const D = new Set();
            B.forEach(E => {
                const F = E.data();
                D.add(`${F.user1Id}+${F.user2Id}`);
            });
            C.forEach(E => {
                const F = E.data();
                D.add(`${F.user1Id}+${F.user2Id}`);
            });

            if (D.size === 0) {
                u += 'Нет активных соединений.\n';
            } else {
                u += 'Активные соединения:\n';
                D.forEach(E => {
                    u += `   ${E} (Отключить: /?disconn=${E})\n`;
                });
            }
            console.log(`[INFO] Список приглашений и соединений для ${userId}:\n${u}`);
        }

        async function s_clear(userId) {
            const t = n('invites');

            try {
                const u = query(t,
                    where("senderId", "==", userId),
                    where("status", "==", "pending")
                );
                const v = await getDocs(u);
                v.forEach(async (w) => {
                    await deleteDoc(doc(t, w.id));
                });

                const x = query(t,
                    where("receiverId", "==", userId),
                    where("status", "==", "pending")
                );
                const y = await getDocs(x);
                y.forEach(async (z) => {
                    await deleteDoc(doc(t, z.id));
                });

                console.log(`[SUCCESS] Все ожидающие приглашения для ${userId} очищены.`);
            } catch (error) {
                console.error("[ERROR] Ошибка при очистке приглашений:", error);
            }
        }

        async function t_status(userId, fallbackText) {
            const u = n('connections');
            try {
                const v = query(u, where("user1Id", "==", userId));
                const w = query(u, where("user2Id", "==", userId));

                const [x, y] = await Promise.all([
                    getDocs(v),
                    getDocs(w)
                ]);

                let connected = false;
                let connectionString = fallbackText;

                x.forEach(z => {
                    const A = z.data();
                    connected = true;
                    connectionString = `${A.user1Id}+${A.user2Id}`;
                });
                y.forEach(z => {
                    const A = z.data();
                    connected = true;
                    connectionString = `${A.user1Id}+${A.user2Id}`;
                });

                console.log(`[INFO] Для ID ${userId}: ${connectionString}`);

            } catch (error) {
                console.error("[ERROR] Ошибка при проверке статуса соединения:", error);
                console.log(`[INFO] Для ID ${userId}: ${fallbackText} (Ошибка)`);
            }
        }

        async function o() {
            if (!e || !d) {
                return;
            }

            const t = new URLSearchParams(window.location.search);
            let u = false;

            const v = window.location.search;
            const w = v.match(/\?(\w+)invite(\w+)/);
            if (w) {
                u = true;
                const x = w[1];
                const y = w[2];
                if (d === x) {
                    console.log(`[INFO] Вы пытаетесь отправить приглашение ${y}. Обработка...`);
                    await q(d, y);
                } else if (d === y) {
                    console.log(`[INFO] Вы получили приглашение от ${x}. Обработка...`);
                    await q(x, d);
                } else {
                    console.log("[INFO] Запрос на приглашение не относится к вашему ID.");
                }
            }

            const x = t.get('invlist');
            if (x && x === d) {
                u = true;
                console.log(`[INFO] Запрос списка приглашений для ${x}.`);
                await r_view(d);
            } else if (x && x !== d) {
                console.log("[ERROR] Вы можете просматривать только свои приглашения.");
            }

            const y = t.get('invkill');
            if (y && y === d) {
                u = true;
                console.log(`[INFO] Запрос на очистку приглашений для ${y}.`);
                await s_clear(d);
            } else if (y && y !== d) {
                console.log("[ERROR] Вы можете удалять только свои приглашения.");
            }

            const z = t.get('disconn');
            if (z) {
                u = true;
                const A = z.split('+');
                if (A.length === 2 && (A[0] === d || A[1] === d)) {
                    console.log(`[INFO] Запрос на разрыв соединения ${z}.`);
                    await p(A[0], A[1]);
                } else {
                    console.log("[ERROR] Неверный формат ID соединения или соединение не относится к вашему ID.");
                }
            }

            const A = t.get('status');
            if (A && A === d) {
                u = true;
                const B = t.get('text') || "Не в коннекте";
                console.log(`[INFO] Запрос статуса соединения для ${A}.`);
                await t_status(d, B);
            } else if (A && A !== d) {
                console.log("[ERROR] Вы можете проверять статус только для своего ID.");
            }

            if (u) {
                history.replaceState({}, document.title, window.location.pathname);
            }
        }

        window.onload = m;
    </script>
</body>
</html>
